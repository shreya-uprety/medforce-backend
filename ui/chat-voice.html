<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical AI Assistant - Chat & Voice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1000px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .mode-btn {
            padding: 8px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .mode-btn.active {
            background: white;
            color: #667eea;
            border-color: white;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .control-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            align-items: center;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            font-size: 13px;
            font-weight: 600;
            color: #555;
            min-width: 100px;
        }

        .control-row input {
            flex: 1;
            padding: 10px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-row input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button.primary {
            background: #667eea;
            color: white;
        }

        button.success {
            background: #10b981;
            color: white;
        }

        button.danger {
            background: #ef4444;
            color: white;
        }

        button.warning {
            background: #f59e0b;
            color: white;
        }

        button.voice-active {
            background: #dc2626;
            color: white;
            animation: pulse-voice 1.5s infinite;
        }

        @keyframes pulse-voice {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }

        .status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px 30px;
            background: #fafafa;
        }

        .message {
            margin-bottom: 16px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .message-sender {
            font-size: 13px;
            font-weight: 600;
            color: #555;
        }

        .message-time {
            font-size: 11px;
            color: #999;
        }

        .message-content {
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            border-left: 3px solid #667eea;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.5;
        }

        .message.user .message-content {
            background: #667eea;
            color: white;
            border-left: 3px solid #5568d3;
        }

        .message.system .message-content {
            background: #fef3c7;
            border-left: 3px solid #f59e0b;
            color: #92400e;
        }

        .typing-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: white;
            border-radius: 12px;
            margin-bottom: 16px;
            border-left: 3px solid #667eea;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
            animation: typing 1.4s infinite;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .input-area {
            padding: 20px 30px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

        .text-input-row {
            display: flex;
            gap: 12px;
        }

        .text-input-row textarea {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            resize: none;
            transition: border-color 0.3s;
        }

        .text-input-row textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .voice-controls {
            display: none;
            justify-content: center;
            gap: 15px;
            padding: 20px;
        }

        .voice-controls.active {
            display: flex;
        }

        .voice-btn-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            font-size: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }

        .voice-btn-large:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .voice-visualizer {
            display: none;
            height: 60px;
            background: #f0f0f0;
            border-radius: 8px;
            margin: 15px 0;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 0 20px;
        }

        .voice-visualizer.active {
            display: flex;
        }

        .voice-bar {
            width: 4px;
            background: #667eea;
            border-radius: 2px;
            transition: height 0.1s;
        }

        .info-panel {
            background: #dbeafe;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 13px;
            color: #1e40af;
        }

        .info-panel strong {
            display: block;
            margin-bottom: 4px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè• Medical AI Assistant</h1>
            <p>Intelligent healthcare companion with voice & text capabilities</p>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="switchMode('chat')">üí¨ Text Chat</button>
                <button class="mode-btn" onclick="switchMode('voice')">üé§ Voice Chat</button>
            </div>
        </div>

        <div class="controls">
            <div class="info-panel">
                <strong>Instructions:</strong> 
                <span id="modeInstructions">Connect to chat with the AI assistant using text or voice</span>
            </div>

            <div class="control-row">
                <label>Patient ID:</label>
                <input type="text" id="patientId" value="p0001" placeholder="Enter patient ID" onchange="updateBoardLink()">
            </div>

            <div class="control-row">
                <label>Server URL:</label>
                <input type="text" id="serverUrl" value="http://localhost:8080" placeholder="Server URL">
            </div>

            <div class="control-row">
                <label>Board URL:</label>
                <a id="boardLink" href="https://clinic-os-v4-235758602997.europe-west1.run.app/board/p0001" target="_blank" style="padding: 10px; color: #667eea; text-decoration: none; font-weight: 600;">
                    üè• Open Board (<span id="boardPatientId">p0001</span>)
                </a>
            </div>

            <div class="control-row">
                <label>Connection:</label>
                <div class="button-group">
                    <button class="success" id="connectBtn" onclick="connect()">
                        üîå Connect
                    </button>
                    <button class="danger" id="disconnectBtn" onclick="disconnect()" disabled>
                        ‚õî Disconnect
                    </button>
                    <button class="primary" onclick="clearMessages()">
                        üóëÔ∏è Clear
                    </button>
                </div>
                <span id="status" class="status disconnected">
                    <span class="status-dot"></span>
                    Disconnected
                </span>
            </div>
        </div>

        <div class="messages" id="messages">
            <!-- Messages will appear here -->
        </div>

        <div class="typing-indicator" id="typingIndicator">
            <span class="message-sender">AI is thinking</span>
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>

        <!-- Text Chat Input -->
        <div class="input-area" id="textInputArea">
            <div class="text-input-row">
                <textarea 
                    id="messageInput" 
                    placeholder="Type your message here..." 
                    rows="3"
                    onkeydown="handleKeyPress(event)"
                ></textarea>
                <button class="primary" onclick="sendMessage()" id="sendBtn" disabled>
                    üì§ Send
                </button>
            </div>
        </div>

        <!-- Voice Chat Controls -->
        <div class="input-area hidden" id="voiceInputArea">
            <div class="voice-visualizer" id="voiceVisualizer">
                <!-- Audio visualization bars -->
            </div>
            <div class="voice-controls active">
                <button class="voice-btn-large success" id="voiceToggleBtn" onclick="toggleVoice()" disabled>
                    üé§
                </button>
            </div>
        </div>
    </div>

    <script>
        let currentMode = 'chat';
        let ws = null;
        let audioContext = null;
        let mediaStream = null;
        let scriptProcessor = null;
        let isVoiceActive = false;
        let isConnected = false;
        
        // Audio playback queue to prevent overlapping
        let audioPlaybackQueue = [];
        let isPlayingAudio = false;
        let currentAudioSource = null;

        // Initialize visualization bars
        function initVoiceVisualizer() {
            const visualizer = document.getElementById('voiceVisualizer');
            visualizer.innerHTML = '';
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'voice-bar';
                bar.style.height = '10px';
                visualizer.appendChild(bar);
            }
        }

        initVoiceVisualizer();

        function log(message, type = 'system') {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const time = new Date().toLocaleTimeString();
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">${type === 'user' ? 'You' : 'AI Assistant'}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${message}</div>
            `;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
        }

        function updateStatus(text, state) {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `<span class="status-dot"></span> ${text}`;
            statusEl.className = `status ${state}`;
        }

        function switchMode(mode) {
            currentMode = mode;
            
            // Update mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update instructions
            const instructions = mode === 'chat' 
                ? 'Type messages to chat with the AI assistant. Press Enter to send.'
                : 'Click the microphone button to start/stop voice conversation. Speak naturally!';
            document.getElementById('modeInstructions').textContent = instructions;
            
            // Show/hide appropriate input areas
            if (mode === 'chat') {
                document.getElementById('textInputArea').classList.remove('hidden');
                document.getElementById('voiceInputArea').classList.add('hidden');
            } else {
                document.getElementById('textInputArea').classList.add('hidden');
                document.getElementById('voiceInputArea').classList.remove('hidden');
            }
            
            // Disconnect if switching modes while connected
            if (isConnected) {
                disconnect();
            }
        }

        function updateBoardLink() {
            const patientId = document.getElementById('patientId').value || 'p0001';
            const boardLink = document.getElementById('boardLink');
            const boardPatientId = document.getElementById('boardPatientId');
            
            boardLink.href = `https://clinic-os-v4-235758602997.europe-west1.run.app/board/${patientId}`;
            boardPatientId.textContent = patientId;
        }

        async function connect() {
            const patientId = document.getElementById('patientId').value;
            const serverUrl = document.getElementById('serverUrl').value;
            
            if (!patientId) {
                alert('Please enter a patient ID');
                return;
            }
            
            // Update board link when connecting
            updateBoardLink();
            
            try {
                updateStatus('Connecting...', 'disconnected');
                
                const wsProtocol = serverUrl.startsWith('https') ? 'wss' : 'ws';
                const wsBaseUrl = serverUrl.replace('http://', '').replace('https://', '');
                
                const endpoint = currentMode === 'chat' ? 'ws/chat' : 'ws/voice';
                const wsUrl = `${wsProtocol}://${wsBaseUrl}/${endpoint}/${patientId}`;
                
                log(`Connecting to ${endpoint}...`, 'system');
                
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';
                
                ws.onopen = async () => {
                    log('‚úÖ Connected successfully!', 'system');
                    updateStatus('Connected', 'connected');
                    isConnected = true;
                    
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    if (currentMode === 'chat') {
                        document.getElementById('sendBtn').disabled = false;
                    } else {
                        document.getElementById('voiceToggleBtn').disabled = false;
                        await initAudio();
                    }
                };
                
                ws.onmessage = (event) => {
                    if (currentMode === 'chat') {
                        handleChatMessage(event);
                    } else {
                        handleVoiceMessage(event);
                    }
                };
                
                ws.onerror = (error) => {
                    log('‚ùå Connection error', 'system');
                    console.error('WebSocket error:', error);
                };
                
                ws.onclose = () => {
                    log('Disconnected from server', 'system');
                    updateStatus('Disconnected', 'disconnected');
                    isConnected = false;
                    isVoiceActive = false;
                    
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                    document.getElementById('sendBtn').disabled = true;
                    document.getElementById('voiceToggleBtn').disabled = true;
                    
                    if (currentMode === 'voice') {
                        cleanupAudio();
                    }
                };
                
            } catch (error) {
                log(`‚ùå Failed to connect: ${error.message}`, 'system');
                updateStatus('Connection failed', 'disconnected');
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
            if (currentMode === 'voice') {
                cleanupAudio();
            }
        }

        function handleChatMessage(event) {
            try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'stream_chunk') {
                    // Handle streaming response
                    let lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                    if (!lastMessage || lastMessage.dataset.complete === 'true') {
                        log('', 'assistant');
                        lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                        lastMessage.dataset.complete = 'false';
                    }
                    lastMessage.textContent += data.content;
                } else if (data.type === 'stream_end') {
                    const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                    if (lastMessage) {
                        lastMessage.dataset.complete = 'true';
                    }
                    document.getElementById('typingIndicator').classList.remove('active');
                } else if (data.type === 'typing') {
                    if (data.is_typing) {
                        document.getElementById('typingIndicator').classList.add('active');
                    } else {
                        document.getElementById('typingIndicator').classList.remove('active');
                    }
                } else if (data.type === 'status') {
                    log(`‚ÑπÔ∏è ${data.message}`, 'system');
                } else if (data.type === 'error') {
                    log(`‚ùå Error: ${data.error}`, 'system');
                }
            } catch (e) {
                console.error('Error parsing message:', e);
            }
        }

        function handleVoiceMessage(event) {
            // Handle JSON status messages (tool calls, errors, etc.)
            if (typeof event.data === 'string') {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'status') {
                        log(`‚ÑπÔ∏è ${data.message}`, 'system');
                    } else if (data.type === 'tool_call') {
                        const emoji = data.status === 'executing' ? 'üîß' : 
                                     data.status === 'completed' ? '‚úÖ' : '‚ùå';
                        const msg = data.status === 'executing' ? `${emoji} Executing ${data.tool}...` :
                                   data.status === 'completed' ? `${emoji} ${data.tool} completed` :
                                   `${emoji} ${data.tool} failed`;
                        log(msg, 'system');
                    } else if (data.type === 'error') {
                        log(`‚ùå Error: ${data.message}`, 'system');
                    }
                    return;
                } catch (e) {
                    // Not JSON, continue to audio handling
                }
            }
            
            // Handle binary audio data
            if (event.data instanceof ArrayBuffer) {
                // Received audio from AI - add to queue
                audioPlaybackQueue.push(event.data);
                processAudioQueue();
                visualizeAudio(new Int16Array(event.data));
            }
            // Backend handles all interruption logic via Gemini Live API
        }
        
        async function processAudioQueue() {
            // Strict lock - if already playing, just return and let current process finish
            if (isPlayingAudio) {
                return;
            }
            
            // Set lock immediately
            isPlayingAudio = true;
            
            try {
                while (audioPlaybackQueue.length > 0) {
                    const audioData = audioPlaybackQueue.shift();
                    await playAudioBuffer(audioData);
                }
            } catch (e) {
                console.error('Error processing audio queue:', e);
            } finally {
                // Always release lock
                isPlayingAudio = false;
            }
        }
        
        function clearAudioQueue() {
            // Clear queue and stop current playback
            audioPlaybackQueue = [];
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                } catch (e) {
                    // Already stopped
                }
                currentAudioSource = null;
            }
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !ws || ws.readyState !== WebSocket.OPEN) return;
            
            log(message, 'user');
            
            ws.send(JSON.stringify({
                message: message,
                stream: true
            }));
            
            input.value = '';
            document.getElementById('typingIndicator').classList.add('active');
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        async function initAudio() {
            try {
                log('üé§ Initializing microphone...', 'system');
                
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Force 16kHz sample rate
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                
                // Verify the actual sample rate
                console.log('AudioContext sample rate:', audioContext.sampleRate);
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                
                // Use larger buffer for more stable processing
                const bufferSize = 2048;
                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
                
                scriptProcessor.onaudioprocess = (e) => {
                    if (!isVoiceActive || !ws || ws.readyState !== WebSocket.OPEN) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(inputData.length);
                    
                    // Convert float32 to int16
                    for (let i = 0; i < inputData.length; i++) {
                        const s = Math.max(-1, Math.min(1, inputData[i]));
                        pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    
                    // Send PCM audio data
                    ws.send(pcmData.buffer);
                    visualizeAudio(pcmData);
                };
                
                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                
                log('‚úÖ Microphone ready (16kHz PCM)', 'system');
                
            } catch (error) {
                log(`‚ùå Microphone error: ${error.message}`, 'system');
                console.error('Audio init error:', error);
            }
        }

        function cleanupAudio() {
            if (scriptProcessor) {
                scriptProcessor.disconnect();
                scriptProcessor = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            document.getElementById('voiceVisualizer').classList.remove('active');
        }

        function toggleVoice() {
            isVoiceActive = !isVoiceActive;
            const btn = document.getElementById('voiceToggleBtn');
            
            if (isVoiceActive) {
                btn.classList.remove('success');
                btn.classList.add('voice-active', 'danger');
                btn.textContent = '‚èπÔ∏è';
                document.getElementById('voiceVisualizer').classList.add('active');
                log('üé§ Voice activated - speak now!', 'system');
            } else {
                btn.classList.remove('voice-active', 'danger');
                btn.classList.add('success');
                btn.textContent = 'üé§';
                document.getElementById('voiceVisualizer').classList.remove('active');
                log('‚è∏Ô∏è Voice paused', 'system');
            }
        }

        function visualizeAudio(audioData) {
            const bars = document.querySelectorAll('.voice-bar');
            const rms = Math.sqrt(audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length);
            
            bars.forEach((bar, i) => {
                const height = Math.min(50, 5 + rms * 1000 + Math.random() * 10);
                bar.style.height = height + 'px';
            });
        }

        async function playAudioBuffer(audioData) {
            try {
                // Ensure audio context is ready
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new AudioContext({ sampleRate: 24000 });
                }
                
                // Resume if suspended
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                const pcmData = new Int16Array(audioData);
                const floatData = new Float32Array(pcmData.length);
                
                for (let i = 0; i < pcmData.length; i++) {
                    floatData[i] = pcmData[i] / (pcmData[i] < 0 ? 0x8000 : 0x7FFF);
                }
                
                const audioBuffer = audioContext.createBuffer(1, floatData.length, 24000);
                audioBuffer.getChannelData(0).set(floatData);
                
                // Create and play audio source
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                // Store reference for interruption
                currentAudioSource = source;
                
                // Wait for this chunk to finish before returning
                await new Promise((resolve, reject) => {
                    let resolved = false;
                    
                    source.onended = () => {
                        if (!resolved) {
                            resolved = true;
                            currentAudioSource = null;
                            resolve();
                        }
                    };
                    
                    // Timeout fallback in case onended doesn't fire
                    const duration = audioBuffer.duration * 1000 + 100; // duration in ms + buffer
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            currentAudioSource = null;
                            resolve();
                        }
                    }, duration);
                    
                    source.start(0);
                });
                
            } catch (error) {
                console.error('Error playing audio buffer:', error);
                currentAudioSource = null;
                // Don't throw - continue to next chunk
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            disconnect();
        });

        // Initial log
        log('Welcome! Select a mode and connect to start.', 'system');
    </script>
</body>
</html>
